---
title: '2022河南萌新联赛第二场部分题解'
author: 'Ghjattu'
date: '2022-07-23'
updated: '2022-07-23'
slug: '2022-he-nan-meng-xin-lian-sai-di-er-chang'
---



## 题目链接

[2022河南萌新联赛第（二）场：河南理工大学](https://ac.nowcoder.com/acm/contest/37344)

## B 宝石

### 思路

对于三个数的乘积，可以考虑先预处理其中两个数的乘积，具体来说，从后往前枚举 $i$ 和 $j$ 且设 $i<j$，假设区间 $[i+1,n]$ 内任意两个数的乘积都保存在 map 中，如果 $a[i]\%a[j]=0$ 且 $a[i]/a[j]$ 在 map 中被标记，说明存在三个数乘积等于 $a[i]$，最后把 $a[i]$ 和区间 $[i,n]$ 中的数的乘积存入 map 中。

### 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
const int N = 1e4 + 7;
const ll INF = 0x3f3f3f3f3f3f3f3f;
const ll MOD = 1e9 + 7;
int n, a[N];
unordered_map<ll, int> mp;

int main() {
//#ifndef ONLINE_JUDGE
//    freopen("in.txt", "r", stdin);
//#endif

    cin >> n;
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    int ans = 0;
    for (int i = n; i >= 1; i--) {
        if (a[i] == 0 && mp[0] == 1) {
            ans++;
            continue;
        }
        for (int j = i + 1; j <= n; j++) {
            if (a[j] == 0)
                continue;
            if (a[i] % a[j] == 0 && mp[a[i] / a[j]] == 1) {
                ans++;
                break;
            }
        }
        for (int j = i; j <= n; j++)
            mp[1LL * a[i] * a[j]] = 1;
    }
    cout << ans;

    return 0;
}
```

## D 数对

### 思路

首先将公式变形为：$(a_l-y)+(a_{l+1}-y)+\dots+(a_{r-1}-y)+(a_r-y)\le x$，令 $b_i=a_i-y$，再对数组 $b$ 求前缀和得到数组 $sum$，继续将公式化简为：$sum_r-x\le sum_{l-1}$ 。此时可以考虑建立一个权值线段树，枚举 $r$，在线段树中查询值大于等于 $sum_r-x$ 的个数，然后把 $sum_r$ 插入到线段树中。由于前缀和数组的值域特别大，因此要先把前缀和数组离散化，注意要把 $sum_i$ 和 $sum_i-x$ 都丢进离散化数组中，同时注意 $sum[0]$ 也需要插入到线段树中。

### 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
const int N = 2e5 + 7;
const ll INF = 0x3f3f3f3f3f3f3f3f;
const ll MOD = 1e9 + 7;
ll x, y, a[N], sum[N];
vector<ll> vec;
int seg[N << 3];

void update(int node, int l, int r, int pos) {
    if (l == r && l == pos) {
        seg[node] += 1;
        return;
    }
    int mid = (l + r) >> 1;
    if (pos <= mid) update(node << 1, l, mid, pos);
    else update(node << 1 | 1, mid + 1, r, pos);
    seg[node] = seg[node << 1] + seg[node << 1 | 1];
}

int query(int node, int l, int r, int ql, int qr) {
    if (r < ql || l > qr)
        return 0;
    if (ql <= l && qr >= r)
        return seg[node];
    int mid = (l + r) >> 1;
    return query(node << 1, l, mid, ql, qr) + query(node << 1 | 1, mid + 1, r, ql, qr);
}

int main() {
//#ifndef ONLINE_JUDGE
//    freopen("in.txt", "r", stdin);
//#endif

    ios::sync_with_stdio(false);
    cin.tie(0);

    int n;
    cin >> n >> x >> y;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        a[i] -= y;
    }
    for (int i = 0; i <= n; i++) {
        if (i > 0) sum[i] = sum[i - 1] + a[i];
        vec.push_back(sum[i]);
        vec.push_back(sum[i] - x);
    }
    sort(vec.begin(), vec.end());
    vec.erase(unique(vec.begin(), vec.end()), vec.end());
    int len = vec.size();
    
    ll ans = 0;
    for (int i = 0; i <= n; i++) {
        int pos1 = lower_bound(vec.begin(), vec.end(), sum[i]) - vec.begin();
        int pos2 = lower_bound(vec.begin(), vec.end(), sum[i] - x) - vec.begin();
        if (i > 0) ans += query(1, 1, len, pos2 + 1, len);
        update(1, 1, len, pos1 + 1);
    }
    cout << ans;

    return 0;
}
```

## K 大米

### 思路

由题意可知，$w_i$ 最初都是奇数，因此每次操作都相当于对区间内的数进行奇偶之间的翻转，考虑用线段树分别维护区间的奇数和 $sum_{odd}$ 和偶数和 $sum_{even}$ ，每次操作将 $sum_{odd}$ 乘 $2$ 、$sum_{even}$ 除以 $2$，然后交换两个值，同时用 lazy 标记判断一个区间是否下传翻转。

### 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
const int N = 2e5 + 7;
const ll INF = 0x3f3f3f3f3f3f3f3f;
const ll MOD = 1e9 + 7;
int n, m, a[N];
struct Node {
    ll oddSum, evenSum;
    int lazy;
} seg[N << 2];

void change(int node) {
    seg[node].lazy ^= 1;
    seg[node].oddSum <<= 1;
    seg[node].evenSum >>= 1;
    swap(seg[node].oddSum, seg[node].evenSum);
}

void pushUp(int node) {
    seg[node].oddSum = seg[node << 1].oddSum + seg[node << 1 | 1].oddSum;
    seg[node].evenSum = seg[node << 1].evenSum + seg[node << 1 | 1].evenSum;
}

void pushDown(int node) {
    if (seg[node].lazy == 0)
        return;
    change(node << 1);
    change(node << 1 | 1);
    seg[node].lazy = 0;
}

void build(int node, int l, int r) {
    if (l == r) {
        seg[node].oddSum = a[l];
        return;
    }
    int mid = (l + r) >> 1;
    build(node << 1, l, mid);
    build(node << 1 | 1, mid + 1, r);
    pushUp(node);
}

void update(int node, int l, int r, int ul, int ur) {
    if (l > ur || r < ul)
        return;
    if (ul <= l && ur >= r) {
        change(node);
        return;
    }
    pushDown(node);
    int mid = (l + r) >> 1;
    update(node << 1, l, mid, ul, ur);
    update(node << 1 | 1, mid + 1, r, ul, ur);
    pushUp(node);
}

int main() {
//#ifndef ONLINE_JUDGE
//    freopen("in.txt", "r", stdin);
//#endif

    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    build(1, 1, n);

    while (m--) {
        int l, r;
        cin >> l >> r;
        update(1, 1, n, l, r);
        cout << seg[1].oddSum + seg[1].evenSum << "\n";
    }

    return 0;
}
```

